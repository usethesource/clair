// This code was generated by lang::cpp::ASTgen
package lang.cpp.internal;

import io.usethesource.vallang.type.Type;
import io.usethesource.vallang.type.TypeFactory;
import io.usethesource.vallang.type.TypeStore;
import io.usethesource.vallang.*;
import java.util.Map;
import java.util.HashMap;

@SuppressWarnings("deprecation")
public class AST {
  private static TypeStore typestore = new TypeStore();
  private static TypeFactory tf = TypeFactory.getInstance();
  private IValueFactory vf;

  public AST (IValueFactory vf) {
    this.vf = vf;
  }

  private static final Type _Declarator = tf.abstractDataType(typestore, "Declarator");
  private static final Type _DeclSpecifier = tf.abstractDataType(typestore, "DeclSpecifier");
  private static final Type _Declaration = tf.abstractDataType(typestore, "Declaration");
  private static final Type _Expression = tf.abstractDataType(typestore, "Expression");
  private static final Type _Type = tf.abstractDataType(typestore, "Type");
  private static final Type _Statement = tf.abstractDataType(typestore, "Statement");
  private static final Type _Modifier = tf.abstractDataType(typestore, "Modifier");
  private static final Type _TypeSymbol = tf.abstractDataType(typestore, "TypeSymbol");
  private static final Type _Attribute = tf.abstractDataType(typestore, "Attribute");
  private static final Type _TypeModifier = tf.abstractDataType(typestore, "TypeModifier");
   
  
  
  private static final Type _Declarator_functionDeclarator_7 
    = tf.constructor(typestore,_Declarator,"functionDeclarator",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers",_Expression,"trailingReturnType");
  private static final Type _Declarator_declarator_4 
    = tf.constructor(typestore,_Declarator,"declarator",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",_Expression,"name",_Expression,"initializer");
  private static final Type _Declarator_functionDeclaratorNoexcept_7 
    = tf.constructor(typestore,_Declarator,"functionDeclaratorNoexcept",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers",_Expression,"noexceptExpression");
  private static final Type _Declarator_arrayDeclarator_5 
    = tf.constructor(typestore,_Declarator,"arrayDeclarator",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",_Expression,"name",tf.listType(_Expression),"arrayModifier",_Expression,"initializer");
  private static final Type _Declarator_fieldDeclarator_5 
    = tf.constructor(typestore,_Declarator,"fieldDeclarator",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",_Expression,"name",_Expression,"bitFieldSize",_Expression,"initializer");
  private static final Type _Declarator_arrayDeclaratorNested_5 
    = tf.constructor(typestore,_Declarator,"arrayDeclaratorNested",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",_Declarator,"declarator",tf.listType(_Expression),"arrayModifier",_Expression,"initializer");
  private static final Type _Declarator_functionDeclaratorWithES_6 
    = tf.constructor(typestore,_Declarator,"functionDeclaratorWithES",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers");
  private static final Type _Declarator_functionDeclaratorNested_7 
    = tf.constructor(typestore,_Declarator,"functionDeclaratorNested",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Declarator,"declarator",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers",_Expression,"initializer");
  private static final Type _Declarator_functionDeclarator_4 
    = tf.constructor(typestore,_Declarator,"functionDeclarator",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",_Expression,"name",tf.listType(_Declaration),"parameters");
  private static final Type _Declarator_functionDeclaratorWithES_7 
    = tf.constructor(typestore,_Declarator,"functionDeclaratorWithES",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers",tf.listType(_Expression),"exceptionSpecification");
  private static final Type _Declarator_functionDeclarator_6 
    = tf.constructor(typestore,_Declarator,"functionDeclarator",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers");
  private static final Type _Declarator_arrayDeclarator_4 
    = tf.constructor(typestore,_Declarator,"arrayDeclarator",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",_Expression,"name",tf.listType(_Expression),"arrayModifier");
  private static final Type _Declarator_fieldDeclarator_4 
    = tf.constructor(typestore,_Declarator,"fieldDeclarator",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",_Expression,"name",_Expression,"bitFieldSize");
  private static final Type _Declarator_missingDeclarator_0 
    = tf.constructor(typestore,_Declarator,"missingDeclarator");
  private static final Type _Declarator_declarator_3 
    = tf.constructor(typestore,_Declarator,"declarator",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",_Expression,"name");
  private static final Type _Declarator_arrayDeclaratorNested_4 
    = tf.constructor(typestore,_Declarator,"arrayDeclaratorNested",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",_Declarator,"declarator",tf.listType(_Expression),"arrayModifier");
  private static final Type _Declarator_functionDeclaratorNested_6 
    = tf.constructor(typestore,_Declarator,"functionDeclaratorNested",tf.listType(_Attribute),"attributes",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Declarator,"declarator",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers");
  
  
  private static final Type _DeclSpecifier_union_5 
    = tf.constructor(typestore,_DeclSpecifier,"union",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"baseSpecifiers",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_struct_3 
    = tf.constructor(typestore,_DeclSpecifier,"struct",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_declSpecifier_3 
    = tf.constructor(typestore,_DeclSpecifier,"declSpecifier",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Type,"type");
  private static final Type _DeclSpecifier_structFinal_5 
    = tf.constructor(typestore,_DeclSpecifier,"structFinal",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"baseSpecifiers",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_classFinal_5 
    = tf.constructor(typestore,_DeclSpecifier,"classFinal",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"baseSpecifiers",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_etsStruct_2 
    = tf.constructor(typestore,_DeclSpecifier,"etsStruct",tf.listType(_Modifier),"modifiers",_Expression,"name");
  private static final Type _DeclSpecifier_class_5 
    = tf.constructor(typestore,_DeclSpecifier,"class",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"baseSpecifiers",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_etsClass_2 
    = tf.constructor(typestore,_DeclSpecifier,"etsClass",tf.listType(_Modifier),"modifiers",_Expression,"name");
  private static final Type _DeclSpecifier_enum_5 
    = tf.constructor(typestore,_DeclSpecifier,"enum",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_DeclSpecifier,"baseType",_Expression,"name",tf.listType(_Declaration),"enumerators");
  private static final Type _DeclSpecifier_union_3 
    = tf.constructor(typestore,_DeclSpecifier,"union",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_namedTypeSpecifier_2 
    = tf.constructor(typestore,_DeclSpecifier,"namedTypeSpecifier",tf.listType(_Modifier),"modifiers",_Expression,"name");
  private static final Type _DeclSpecifier_etsUnion_2 
    = tf.constructor(typestore,_DeclSpecifier,"etsUnion",tf.listType(_Modifier),"modifiers",_Expression,"name");
  private static final Type _DeclSpecifier_etsEnum_2 
    = tf.constructor(typestore,_DeclSpecifier,"etsEnum",tf.listType(_Modifier),"modifiers",_Expression,"name");
  private static final Type _DeclSpecifier_enumScoped_5 
    = tf.constructor(typestore,_DeclSpecifier,"enumScoped",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_DeclSpecifier,"baseType",_Expression,"name",tf.listType(_Declaration),"enumerators");
  private static final Type _DeclSpecifier_unionFinal_5 
    = tf.constructor(typestore,_DeclSpecifier,"unionFinal",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"baseSpecifiers",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_enumScopedOpaque_4 
    = tf.constructor(typestore,_DeclSpecifier,"enumScopedOpaque",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_DeclSpecifier,"baseType",_Expression,"name");
  private static final Type _DeclSpecifier_class_3 
    = tf.constructor(typestore,_DeclSpecifier,"class",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_msThrowEllipsis_0 
    = tf.constructor(typestore,_DeclSpecifier,"msThrowEllipsis");
  private static final Type _DeclSpecifier_enum_4 
    = tf.constructor(typestore,_DeclSpecifier,"enum",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"enumerators");
  private static final Type _DeclSpecifier_declSpecifier_4 
    = tf.constructor(typestore,_DeclSpecifier,"declSpecifier",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Type,"type",_Expression,"expression");
  private static final Type _DeclSpecifier_enumScopedOpaque_3 
    = tf.constructor(typestore,_DeclSpecifier,"enumScopedOpaque",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Expression,"name");
  private static final Type _DeclSpecifier_enumOpaque_4 
    = tf.constructor(typestore,_DeclSpecifier,"enumOpaque",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_DeclSpecifier,"baseType",_Expression,"name");
  private static final Type _DeclSpecifier_enumScoped_4 
    = tf.constructor(typestore,_DeclSpecifier,"enumScoped",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"enumerators");
  private static final Type _DeclSpecifier_struct_5 
    = tf.constructor(typestore,_DeclSpecifier,"struct",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Expression,"name",tf.listType(_Declaration),"baseSpecifiers",tf.listType(_Declaration),"members");
  
  
  private static final Type _Declaration_tttParameter_2 
    = tf.constructor(typestore,_Declaration,"tttParameter",tf.listType(_Declaration),"nestedParameters",_Expression,"name");
  private static final Type _Declaration_namespaceDefinitionInline_3 
    = tf.constructor(typestore,_Declaration,"namespaceDefinitionInline",tf.listType(_Attribute),"attributes",_Expression,"name",tf.listType(_Declaration),"declarations");
  private static final Type _Declaration_functionDefinition_3 
    = tf.constructor(typestore,_Declaration,"functionDefinition",_Expression,"returnSpec",_Declarator,"declarator",_Statement,"body");
  private static final Type _Declaration_explicitTemplateSpecialization_1 
    = tf.constructor(typestore,_Declaration,"explicitTemplateSpecialization",_Declaration,"declaration");
  private static final Type _Declaration_functionDefinition_5 
    = tf.constructor(typestore,_Declaration,"functionDefinition",tf.listType(_Attribute),"attributes",_DeclSpecifier,"declSpecifier",_Declarator,"declarator",tf.listType(_Expression),"memberInitializer",_Statement,"body");
  private static final Type _Declaration_baseSpecifier_1 
    = tf.constructor(typestore,_Declaration,"baseSpecifier",tf.listType(_Modifier),"modifiers");
  private static final Type _Declaration_reference_1 
    = tf.constructor(typestore,_Declaration,"reference",tf.listType(_Attribute),"attributes");
  private static final Type _Declaration_namespaceAlias_2 
    = tf.constructor(typestore,_Declaration,"namespaceAlias",_Expression,"alias",_Expression,"mapping");
  private static final Type _Declaration_enumerator_1 
    = tf.constructor(typestore,_Declaration,"enumerator",_Expression,"name");
  private static final Type _Declaration_parameter_1 
    = tf.constructor(typestore,_Declaration,"parameter",_DeclSpecifier,"declSpecifier");
  private static final Type _Declaration_explicitTemplateInstantiation_2 
    = tf.constructor(typestore,_Declaration,"explicitTemplateInstantiation",_Modifier,"modifier",_Declaration,"declaration");
  private static final Type _Declaration_sttClass_1 
    = tf.constructor(typestore,_Declaration,"sttClass",_Expression,"name");
  private static final Type _Declaration_virtSpecifier_1 
    = tf.constructor(typestore,_Declaration,"virtSpecifier",_Modifier,"modifier");
  private static final Type _Declaration_pointerToMember_3 
    = tf.constructor(typestore,_Declaration,"pointerToMember",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Expression,"nestedName");
  private static final Type _Declaration_staticAssert_2 
    = tf.constructor(typestore,_Declaration,"staticAssert",_Expression,"condition",_Expression,"message");
  private static final Type _Declaration_functionWithTryBlockDefinition_6 
    = tf.constructor(typestore,_Declaration,"functionWithTryBlockDefinition",tf.listType(_Attribute),"attributes",_DeclSpecifier,"declSpecifier",_Declarator,"declarator",tf.listType(_Expression),"memberInitializers",_Statement,"sbody",tf.listType(_Statement),"catchHandlers");
  private static final Type _Declaration_visibilityLabel_1 
    = tf.constructor(typestore,_Declaration,"visibilityLabel",_Modifier,"visibility");
  private static final Type _Declaration_namespaceDefinition_3 
    = tf.constructor(typestore,_Declaration,"namespaceDefinition",tf.listType(_Attribute),"attributes",_Expression,"name",tf.listType(_Declaration),"declarations");
  private static final Type _Declaration_translationUnit_1 
    = tf.constructor(typestore,_Declaration,"translationUnit",tf.listType(_Declaration),"declarations");
  private static final Type _Declaration_enumerator_2 
    = tf.constructor(typestore,_Declaration,"enumerator",_Expression,"name",_Expression,"value");
  private static final Type _Declaration_pointer_2 
    = tf.constructor(typestore,_Declaration,"pointer",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers");
  private static final Type _Declaration_sttClass_2 
    = tf.constructor(typestore,_Declaration,"sttClass",_Expression,"name",_Expression,"defaultType");
  private static final Type _Declaration_parameter_2 
    = tf.constructor(typestore,_Declaration,"parameter",_DeclSpecifier,"declSpecifier",_Declarator,"declarator");
  private static final Type _Declaration_baseSpecifier_2 
    = tf.constructor(typestore,_Declaration,"baseSpecifier",tf.listType(_Modifier),"modifiers",_Expression,"name");
  private static final Type _Declaration_problemDeclaration_0 
    = tf.constructor(typestore,_Declaration,"problemDeclaration");
  private static final Type _Declaration_varArgs_0 
    = tf.constructor(typestore,_Declaration,"varArgs");
  private static final Type _Declaration_template_2 
    = tf.constructor(typestore,_Declaration,"template",tf.listType(_Declaration),"parameters",_Declaration,"declaration");
  private static final Type _Declaration_alias_3 
    = tf.constructor(typestore,_Declaration,"alias",tf.listType(_Attribute),"attributes",_Expression,"alias",_Expression,"mappingTypeId");
  private static final Type _Declaration_deletedFunctionDefinition_4 
    = tf.constructor(typestore,_Declaration,"deletedFunctionDefinition",tf.listType(_Attribute),"attributes",_DeclSpecifier,"declSpecifier",tf.listType(_Expression),"memberInitializer",_Declarator,"declarator");
  private static final Type _Declaration_sttTypename_2 
    = tf.constructor(typestore,_Declaration,"sttTypename",_Expression,"name",_Expression,"defaultType");
  private static final Type _Declaration_usingDirective_2 
    = tf.constructor(typestore,_Declaration,"usingDirective",tf.listType(_Attribute),"attributes",_Expression,"qualifiedName");
  private static final Type _Declaration_explicitTemplateInstantiation_1 
    = tf.constructor(typestore,_Declaration,"explicitTemplateInstantiation",_Declaration,"declaration");
  private static final Type _Declaration_linkageSpecification_2 
    = tf.constructor(typestore,_Declaration,"linkageSpecification",tf.stringType(),"literal",tf.listType(_Declaration),"declarations");
  private static final Type _Declaration_simpleDeclaration_3 
    = tf.constructor(typestore,_Declaration,"simpleDeclaration",tf.listType(_Attribute),"attributes",_DeclSpecifier,"declSpecifier",tf.listType(_Declarator),"declarators");
  private static final Type _Declaration_defaultedFunctionDefinition_4 
    = tf.constructor(typestore,_Declaration,"defaultedFunctionDefinition",tf.listType(_Attribute),"attributes",_DeclSpecifier,"declSpecifier",tf.listType(_Expression),"memberInitializer",_Declarator,"declarator");
  private static final Type _Declaration_sttTypename_1 
    = tf.constructor(typestore,_Declaration,"sttTypename",_Expression,"name");
  private static final Type _Declaration_usingDeclaration_3 
    = tf.constructor(typestore,_Declaration,"usingDeclaration",tf.listType(_Attribute),"attributes",tf.listType(_Modifier),"modifiers",_Expression,"name");
  private static final Type _Declaration_asmDeclaration_1 
    = tf.constructor(typestore,_Declaration,"asmDeclaration",tf.stringType(),"assembly");
  private static final Type _Declaration_rvalueReference_1 
    = tf.constructor(typestore,_Declaration,"rvalueReference",tf.listType(_Attribute),"attributes");
  
  
  private static final Type _Expression_empty_0 
    = tf.constructor(typestore,_Expression,"empty");
  private static final Type _Expression_arrayDesignator_1 
    = tf.constructor(typestore,_Expression,"arrayDesignator",_Expression,"subscript");
  private static final Type _Expression_sizeofParameterPack_1 
    = tf.constructor(typestore,_Expression,"sizeofParameterPack",_Expression,"expression");
  private static final Type _Expression_minusAssign_2 
    = tf.constructor(typestore,_Expression,"minusAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_equals_2 
    = tf.constructor(typestore,_Expression,"equals",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_charConstant_1 
    = tf.constructor(typestore,_Expression,"charConstant",tf.stringType(),"value");
  private static final Type _Expression_typeid_1 
    = tf.constructor(typestore,_Expression,"typeid",_Expression,"expression");
  private static final Type _Expression_true_0 
    = tf.constructor(typestore,_Expression,"true");
  private static final Type _Expression_labelReference_1 
    = tf.constructor(typestore,_Expression,"labelReference",_Expression,"expression");
  private static final Type _Expression_typeId_1 
    = tf.constructor(typestore,_Expression,"typeId",_DeclSpecifier,"declSpecifier");
  private static final Type _Expression_minus_1 
    = tf.constructor(typestore,_Expression,"minus",_Expression,"expression");
  private static final Type _Expression_greaterThan_2 
    = tf.constructor(typestore,_Expression,"greaterThan",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_lessEqual_2 
    = tf.constructor(typestore,_Expression,"lessEqual",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_arrayModifier_2 
    = tf.constructor(typestore,_Expression,"arrayModifier",tf.listType(_Attribute),"attributes",_Expression,"constExpression");
  private static final Type _Expression_globalVectoredDelete_1 
    = tf.constructor(typestore,_Expression,"globalVectoredDelete",_Expression,"expression");
  private static final Type _Expression_functionCall_2 
    = tf.constructor(typestore,_Expression,"functionCall",_Expression,"functionName",tf.listType(_Expression),"arguments");
  private static final Type _Expression_binaryXor_2 
    = tf.constructor(typestore,_Expression,"binaryXor",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_amper_1 
    = tf.constructor(typestore,_Expression,"amper",_Expression,"expression");
  private static final Type _Expression_plus_2 
    = tf.constructor(typestore,_Expression,"plus",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_stringLiteral_1 
    = tf.constructor(typestore,_Expression,"stringLiteral",tf.stringType(),"value");
  private static final Type _Expression_shiftRight_2 
    = tf.constructor(typestore,_Expression,"shiftRight",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_captureThisPtr_0 
    = tf.constructor(typestore,_Expression,"captureThisPtr");
  private static final Type _Expression_greaterEqual_2 
    = tf.constructor(typestore,_Expression,"greaterEqual",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_lessThan_2 
    = tf.constructor(typestore,_Expression,"lessThan",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_arraySubscriptExpression_2 
    = tf.constructor(typestore,_Expression,"arraySubscriptExpression",_Expression,"array",_Expression,"argument");
  private static final Type _Expression_divide_2 
    = tf.constructor(typestore,_Expression,"divide",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_fieldReferencePointerDeref_2 
    = tf.constructor(typestore,_Expression,"fieldReferencePointerDeref",_Expression,"fieldOnwer",_Expression,"name");
  private static final Type _Expression_uuidof_1 
    = tf.constructor(typestore,_Expression,"uuidof",_Expression,"expression");
  private static final Type _Expression_star_1 
    = tf.constructor(typestore,_Expression,"star",_Expression,"expression");
  private static final Type _Expression_conversionName_2 
    = tf.constructor(typestore,_Expression,"conversionName",tf.stringType(),"value",_Expression,"typeId");
  private static final Type _Expression_typeId_2 
    = tf.constructor(typestore,_Expression,"typeId",_DeclSpecifier,"declSpecifier",_Declarator,"abstractDeclarator");
  private static final Type _Expression_shiftLeftAssign_2 
    = tf.constructor(typestore,_Expression,"shiftLeftAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_not_1 
    = tf.constructor(typestore,_Expression,"not",_Expression,"expression");
  private static final Type _Expression_idExpression_1 
    = tf.constructor(typestore,_Expression,"idExpression",_Expression,"name");
  private static final Type _Expression_fieldReference_2 
    = tf.constructor(typestore,_Expression,"fieldReference",_Expression,"fieldOwner",_Expression,"name");
  private static final Type _Expression_initializerList_1 
    = tf.constructor(typestore,_Expression,"initializerList",tf.listType(_Expression),"clauses");
  private static final Type _Expression_alignOf_1 
    = tf.constructor(typestore,_Expression,"alignOf",_Expression,"expression");
  private static final Type _Expression_nullptr_0 
    = tf.constructor(typestore,_Expression,"nullptr");
  private static final Type _Expression_throw_0 
    = tf.constructor(typestore,_Expression,"throw");
  private static final Type _Expression_modulo_2 
    = tf.constructor(typestore,_Expression,"modulo",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_binaryAnd_2 
    = tf.constructor(typestore,_Expression,"binaryAnd",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_dynamicCast_2 
    = tf.constructor(typestore,_Expression,"dynamicCast",_Expression,"typeId",_Expression,"expression");
  private static final Type _Expression_ellipses_2 
    = tf.constructor(typestore,_Expression,"ellipses",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_simpleTypeConstructor_2 
    = tf.constructor(typestore,_Expression,"simpleTypeConstructor",_DeclSpecifier,"declSpecifier",_Expression,"initializer");
  private static final Type _Expression_globalNew_2 
    = tf.constructor(typestore,_Expression,"globalNew",_Expression,"typeId",_Expression,"initializer");
  private static final Type _Expression_qualifiedName_2 
    = tf.constructor(typestore,_Expression,"qualifiedName",tf.listType(_Expression),"qualifiers",_Expression,"lastName");
  private static final Type _Expression_cast_2 
    = tf.constructor(typestore,_Expression,"cast",_Expression,"typeId",_Expression,"expression");
  private static final Type _Expression_multiplyAssign_2 
    = tf.constructor(typestore,_Expression,"multiplyAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_sizeof_1 
    = tf.constructor(typestore,_Expression,"sizeof",_Expression,"expression");
  private static final Type _Expression_false_0 
    = tf.constructor(typestore,_Expression,"false");
  private static final Type _Expression_tilde_1 
    = tf.constructor(typestore,_Expression,"tilde",_Expression,"expression");
  private static final Type _Expression_binaryOrAssign_2 
    = tf.constructor(typestore,_Expression,"binaryOrAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_notEquals_2 
    = tf.constructor(typestore,_Expression,"notEquals",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_arrayRangeDesignator_2 
    = tf.constructor(typestore,_Expression,"arrayRangeDesignator",_Expression,"rangeFloor",_Expression,"rangeCeiling");
  private static final Type _Expression_min_2 
    = tf.constructor(typestore,_Expression,"min",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_reinterpretCast_2 
    = tf.constructor(typestore,_Expression,"reinterpretCast",_Expression,"typeId",_Expression,"expression");
  private static final Type _Expression_captureByRef_1 
    = tf.constructor(typestore,_Expression,"captureByRef",_Expression,"name");
  private static final Type _Expression_constructorInitializer_1 
    = tf.constructor(typestore,_Expression,"constructorInitializer",tf.listType(_Expression),"arguments");
  private static final Type _Expression_plus_1 
    = tf.constructor(typestore,_Expression,"plus",_Expression,"expression");
  private static final Type _Expression_noexcept_1 
    = tf.constructor(typestore,_Expression,"noexcept",_Expression,"expression");
  private static final Type _Expression_minus_2 
    = tf.constructor(typestore,_Expression,"minus",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_new_1 
    = tf.constructor(typestore,_Expression,"new",_Expression,"typeId");
  private static final Type _Expression_nyi_1 
    = tf.constructor(typestore,_Expression,"nyi",tf.stringType(),"raw");
  private static final Type _Expression_assign_2 
    = tf.constructor(typestore,_Expression,"assign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_name_1 
    = tf.constructor(typestore,_Expression,"name",tf.stringType(),"value");
  private static final Type _Expression_postfixDecr_1 
    = tf.constructor(typestore,_Expression,"postfixDecr",_Expression,"expression");
  private static final Type _Expression_this_0 
    = tf.constructor(typestore,_Expression,"this");
  private static final Type _Expression_logicalAnd_2 
    = tf.constructor(typestore,_Expression,"logicalAnd",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_throw_1 
    = tf.constructor(typestore,_Expression,"throw",_Expression,"expression");
  private static final Type _Expression_prefixIncr_1 
    = tf.constructor(typestore,_Expression,"prefixIncr",_Expression,"expression");
  private static final Type _Expression_globalNew_1 
    = tf.constructor(typestore,_Expression,"globalNew",_Expression,"typeId");
  private static final Type _Expression_pmArrow_2 
    = tf.constructor(typestore,_Expression,"pmArrow",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_pmDot_2 
    = tf.constructor(typestore,_Expression,"pmDot",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_bracketed_1 
    = tf.constructor(typestore,_Expression,"bracketed",_Expression,"expression");
  private static final Type _Expression_logicalOr_2 
    = tf.constructor(typestore,_Expression,"logicalOr",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_equalsInitializer_1 
    = tf.constructor(typestore,_Expression,"equalsInitializer",_Expression,"initializer");
  private static final Type _Expression_constructorChainInitializer_2 
    = tf.constructor(typestore,_Expression,"constructorChainInitializer",_Expression,"name",_Expression,"initializer");
  private static final Type _Expression_integerLiteral_1 
    = tf.constructor(typestore,_Expression,"integerLiteral",tf.integerType(),"number");
  private static final Type _Expression_operatorName_1 
    = tf.constructor(typestore,_Expression,"operatorName",tf.stringType(),"value");
  private static final Type _Expression_shiftRightAssign_2 
    = tf.constructor(typestore,_Expression,"shiftRightAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_constCast_2 
    = tf.constructor(typestore,_Expression,"constCast",_Expression,"typeId",_Expression,"expression");
  private static final Type _Expression_binaryXorAssign_2 
    = tf.constructor(typestore,_Expression,"binaryXorAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_prefixDecr_1 
    = tf.constructor(typestore,_Expression,"prefixDecr",_Expression,"expression");
  private static final Type _Expression_plusAssign_2 
    = tf.constructor(typestore,_Expression,"plusAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_lambda_4 
    = tf.constructor(typestore,_Expression,"lambda",_Modifier,"captureDefault",tf.listType(_Expression),"captures",_Declarator,"declarator",_Statement,"body");
  private static final Type _Expression_shiftLeft_2 
    = tf.constructor(typestore,_Expression,"shiftLeft",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_new_2 
    = tf.constructor(typestore,_Expression,"new",_Expression,"typeId",_Expression,"initializer");
  private static final Type _Expression_divideAssign_2 
    = tf.constructor(typestore,_Expression,"divideAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_newWithArgs_2 
    = tf.constructor(typestore,_Expression,"newWithArgs",tf.listType(_Expression),"arguments",_Expression,"typeId");
  private static final Type _Expression_designatedInitializer_2 
    = tf.constructor(typestore,_Expression,"designatedInitializer",tf.listType(_Expression),"designators",_Expression,"operand");
  private static final Type _Expression_problemExpression_0 
    = tf.constructor(typestore,_Expression,"problemExpression");
  private static final Type _Expression_abstractEmptyName_0 
    = tf.constructor(typestore,_Expression,"abstractEmptyName");
  private static final Type _Expression_vectoredDelete_1 
    = tf.constructor(typestore,_Expression,"vectoredDelete",_Expression,"expression");
  private static final Type _Expression_integerConstant_1 
    = tf.constructor(typestore,_Expression,"integerConstant",tf.stringType(),"value");
  private static final Type _Expression_staticCast_2 
    = tf.constructor(typestore,_Expression,"staticCast",_Expression,"typeId",_Expression,"expression");
  private static final Type _Expression_packExpansion_1 
    = tf.constructor(typestore,_Expression,"packExpansion",_Expression,"pattern");
  private static final Type _Expression_binaryAndAssign_2 
    = tf.constructor(typestore,_Expression,"binaryAndAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_conditional_3 
    = tf.constructor(typestore,_Expression,"conditional",_Expression,"condition",_Expression,"positive",_Expression,"negative");
  private static final Type _Expression_moduloAssign_2 
    = tf.constructor(typestore,_Expression,"moduloAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_globalDelete_1 
    = tf.constructor(typestore,_Expression,"globalDelete",_Expression,"expression");
  private static final Type _Expression_max_2 
    = tf.constructor(typestore,_Expression,"max",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_binaryOr_2 
    = tf.constructor(typestore,_Expression,"binaryOr",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_multiply_2 
    = tf.constructor(typestore,_Expression,"multiply",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_floatConstant_1 
    = tf.constructor(typestore,_Expression,"floatConstant",tf.stringType(),"value");
  private static final Type _Expression_globalNewWithArgs_2 
    = tf.constructor(typestore,_Expression,"globalNewWithArgs",tf.listType(_Expression),"arguments",_Expression,"typeId");
  private static final Type _Expression_fieldDesignator_1 
    = tf.constructor(typestore,_Expression,"fieldDesignator",_Expression,"fieldName");
  private static final Type _Expression_newWithArgs_3 
    = tf.constructor(typestore,_Expression,"newWithArgs",tf.listType(_Expression),"arguments",_Expression,"typeId",_Expression,"initializer");
  private static final Type _Expression_arrayModifier_1 
    = tf.constructor(typestore,_Expression,"arrayModifier",tf.listType(_Attribute),"attributes");
  private static final Type _Expression_postfixIncr_1 
    = tf.constructor(typestore,_Expression,"postfixIncr",_Expression,"expression");
  private static final Type _Expression_capture_1 
    = tf.constructor(typestore,_Expression,"capture",_Expression,"name");
  private static final Type _Expression_globalNewWithArgs_3 
    = tf.constructor(typestore,_Expression,"globalNewWithArgs",tf.listType(_Expression),"arguments",_Expression,"typeId",_Expression,"initializer");
  private static final Type _Expression_expressionList_1 
    = tf.constructor(typestore,_Expression,"expressionList",tf.listType(_Expression),"expressions");
  private static final Type _Expression_delete_1 
    = tf.constructor(typestore,_Expression,"delete",_Expression,"expression");
  private static final Type _Expression_templateId_2 
    = tf.constructor(typestore,_Expression,"templateId",_Expression,"name",tf.listType(_Expression),"argumentTypes");
  
  
  private static final Type _Type_wchar_t_0 
    = tf.constructor(typestore,_Type,"wchar_t");
  private static final Type _Type_decltype_0 
    = tf.constructor(typestore,_Type,"decltype");
  private static final Type _Type_decimal128_0 
    = tf.constructor(typestore,_Type,"decimal128");
  private static final Type _Type_nullptr_0 
    = tf.constructor(typestore,_Type,"nullptr");
  private static final Type _Type_int128_0 
    = tf.constructor(typestore,_Type,"int128");
  private static final Type _Type_classType_1 
    = tf.constructor(typestore,_Type,"classType",_Expression,"name");
  private static final Type _Type_unionType_1 
    = tf.constructor(typestore,_Type,"unionType",_Expression,"name");
  private static final Type _Type_basicType_2 
    = tf.constructor(typestore,_Type,"basicType",_Type,"type",tf.listType(_Modifier),"modifiers");
  private static final Type _Type_char_0 
    = tf.constructor(typestore,_Type,"char");
  private static final Type _Type_unspecified_0 
    = tf.constructor(typestore,_Type,"unspecified");
  private static final Type _Type_arrayType_2 
    = tf.constructor(typestore,_Type,"arrayType",_Type,"type",tf.integerType(),"size");
  private static final Type _Type_float128_0 
    = tf.constructor(typestore,_Type,"float128");
  private static final Type _Type_float_0 
    = tf.constructor(typestore,_Type,"float");
  private static final Type _Type_integer_0 
    = tf.constructor(typestore,_Type,"integer");
  private static final Type _Type_char32_t_0 
    = tf.constructor(typestore,_Type,"char32_t");
  private static final Type _Type_bool_0 
    = tf.constructor(typestore,_Type,"bool");
  private static final Type _Type_decimal64_0 
    = tf.constructor(typestore,_Type,"decimal64");
  private static final Type _Type_auto_0 
    = tf.constructor(typestore,_Type,"auto");
  private static final Type _Type_decimal32_0 
    = tf.constructor(typestore,_Type,"decimal32");
  private static final Type _Type_char16_t_0 
    = tf.constructor(typestore,_Type,"char16_t");
  private static final Type _Type_typeof_0 
    = tf.constructor(typestore,_Type,"typeof");
  private static final Type _Type_double_0 
    = tf.constructor(typestore,_Type,"double");
  private static final Type _Type_structType_1 
    = tf.constructor(typestore,_Type,"structType",_Expression,"name");
  private static final Type _Type_void_0 
    = tf.constructor(typestore,_Type,"void");
  
  
  private static final Type _Statement_goto_2 
    = tf.constructor(typestore,_Statement,"goto",tf.listType(_Attribute),"attributes",_Expression,"name");
  private static final Type _Statement_for_5 
    = tf.constructor(typestore,_Statement,"for",tf.listType(_Attribute),"attributes",_Statement,"sInitializer",_Expression,"condition",_Expression,"iteration",_Statement,"body");
  private static final Type _Statement_label_3 
    = tf.constructor(typestore,_Statement,"label",tf.listType(_Attribute),"attributes",_Expression,"name",_Statement,"nestedStatement");
  private static final Type _Statement_while_3 
    = tf.constructor(typestore,_Statement,"while",tf.listType(_Attribute),"attributes",_Expression,"condition",_Statement,"body");
  private static final Type _Statement_ifNotExists_3 
    = tf.constructor(typestore,_Statement,"ifNotExists",tf.listType(_Attribute),"attributes",_Expression,"condition",_Statement,"thenClause");
  private static final Type _Statement_ifWithDecl_3 
    = tf.constructor(typestore,_Statement,"ifWithDecl",tf.listType(_Attribute),"attributes",_Declaration,"conditionDeclaration",_Statement,"thenClause");
  private static final Type _Statement_break_1 
    = tf.constructor(typestore,_Statement,"break",tf.listType(_Attribute),"attributes");
  private static final Type _Statement_tryExcept_4 
    = tf.constructor(typestore,_Statement,"tryExcept",tf.listType(_Attribute),"attributes",_Statement,"tryBody",_Expression,"exceptFilter",_Statement,"exceptBody");
  private static final Type _Statement_problem_1 
    = tf.constructor(typestore,_Statement,"problem",tf.stringType(),"raw");
  private static final Type _Statement_continue_1 
    = tf.constructor(typestore,_Statement,"continue",tf.listType(_Attribute),"attributes");
  private static final Type _Statement_switchWithDecl_3 
    = tf.constructor(typestore,_Statement,"switchWithDecl",tf.listType(_Attribute),"attributes",_Declaration,"controllerDeclaration",_Statement,"body");
  private static final Type _Statement_ifWithDecl_4 
    = tf.constructor(typestore,_Statement,"ifWithDecl",tf.listType(_Attribute),"attributes",_Declaration,"conditionDeclaration",_Statement,"thenClause",_Statement,"elseClause");
  private static final Type _Statement_expressionStatement_2 
    = tf.constructor(typestore,_Statement,"expressionStatement",tf.listType(_Attribute),"attributes",_Expression,"expression");
  private static final Type _Statement_ifExists_3 
    = tf.constructor(typestore,_Statement,"ifExists",tf.listType(_Attribute),"attributes",_Expression,"condition",_Statement,"thenClause");
  private static final Type _Statement_defaultCase_1 
    = tf.constructor(typestore,_Statement,"defaultCase",tf.listType(_Attribute),"attributes");
  private static final Type _Statement_return_1 
    = tf.constructor(typestore,_Statement,"return",tf.listType(_Attribute),"attributes");
  private static final Type _Statement_rangeBasedFor_4 
    = tf.constructor(typestore,_Statement,"rangeBasedFor",tf.listType(_Attribute),"attributes",_Declaration,"declaration",_Expression,"initializer",_Statement,"body");
  private static final Type _Statement_whileWithDecl_3 
    = tf.constructor(typestore,_Statement,"whileWithDecl",tf.listType(_Attribute),"attributes",_Declaration,"conditionDeclaration",_Statement,"body");
  private static final Type _Statement_switch_3 
    = tf.constructor(typestore,_Statement,"switch",tf.listType(_Attribute),"attributes",_Expression,"controller",_Statement,"body");
  private static final Type _Statement_do_3 
    = tf.constructor(typestore,_Statement,"do",tf.listType(_Attribute),"attributes",_Statement,"body",_Expression,"condition");
  private static final Type _Statement_if_3 
    = tf.constructor(typestore,_Statement,"if",tf.listType(_Attribute),"attributes",_Expression,"condition",_Statement,"thenClause");
  private static final Type _Statement_tryBlock_3 
    = tf.constructor(typestore,_Statement,"tryBlock",tf.listType(_Attribute),"attributes",_Statement,"tryBody",tf.listType(_Statement),"catchHandlers");
  private static final Type _Statement_forWithDecl_5 
    = tf.constructor(typestore,_Statement,"forWithDecl",tf.listType(_Attribute),"attributes",_Statement,"sInitializer",_Declaration,"conditionDeclaration",_Expression,"iteration",_Statement,"body");
  private static final Type _Statement_tryFinally_3 
    = tf.constructor(typestore,_Statement,"tryFinally",tf.listType(_Attribute),"attributes",_Statement,"tryBody",_Statement,"finallyBody");
  private static final Type _Statement_nullStatement_1 
    = tf.constructor(typestore,_Statement,"nullStatement",tf.listType(_Attribute),"attributes");
  private static final Type _Statement_declarationStatement_2 
    = tf.constructor(typestore,_Statement,"declarationStatement",tf.listType(_Attribute),"attributes",_Declaration,"declaration");
  private static final Type _Statement_asm_1 
    = tf.constructor(typestore,_Statement,"asm",tf.stringType(),"assembly");
  private static final Type _Statement_catchAll_2 
    = tf.constructor(typestore,_Statement,"catchAll",tf.listType(_Attribute),"attributes",_Statement,"body");
  private static final Type _Statement_compoundStatement_2 
    = tf.constructor(typestore,_Statement,"compoundStatement",tf.listType(_Attribute),"attributes",tf.listType(_Statement),"statements");
  private static final Type _Statement_if_4 
    = tf.constructor(typestore,_Statement,"if",tf.listType(_Attribute),"attributes",_Expression,"condition",_Statement,"thenClause",_Statement,"elseClause");
  private static final Type _Statement_case_2 
    = tf.constructor(typestore,_Statement,"case",tf.listType(_Attribute),"attributes",_Expression,"expression");
  private static final Type _Statement_catch_3 
    = tf.constructor(typestore,_Statement,"catch",tf.listType(_Attribute),"attributes",_Declaration,"declaration",_Statement,"body");
  private static final Type _Statement_return_2 
    = tf.constructor(typestore,_Statement,"return",tf.listType(_Attribute),"attributes",_Expression,"expression");
  
  
  private static final Type _Modifier_override_0 
    = tf.constructor(typestore,_Modifier,"override");
  private static final Type _Modifier_public_0 
    = tf.constructor(typestore,_Modifier,"public");
  private static final Type _Modifier_typename_0 
    = tf.constructor(typestore,_Modifier,"typename");
  private static final Type _Modifier_mutable_0 
    = tf.constructor(typestore,_Modifier,"mutable");
  private static final Type _Modifier_threadLocal_0 
    = tf.constructor(typestore,_Modifier,"threadLocal");
  private static final Type _Modifier_extern_0 
    = tf.constructor(typestore,_Modifier,"extern");
  private static final Type _Modifier_friend_0 
    = tf.constructor(typestore,_Modifier,"friend");
  private static final Type _Modifier_unsigned_0 
    = tf.constructor(typestore,_Modifier,"unsigned");
  private static final Type _Modifier_final_0 
    = tf.constructor(typestore,_Modifier,"final");
  private static final Type _Modifier_captDefByReference_0 
    = tf.constructor(typestore,_Modifier,"captDefByReference");
  private static final Type _Modifier_complex_0 
    = tf.constructor(typestore,_Modifier,"complex");
  private static final Type _Modifier_auto_0 
    = tf.constructor(typestore,_Modifier,"auto");
  private static final Type _Modifier_captDefByCopy_0 
    = tf.constructor(typestore,_Modifier,"captDefByCopy");
  private static final Type _Modifier_protected_0 
    = tf.constructor(typestore,_Modifier,"protected");
  private static final Type _Modifier_static_0 
    = tf.constructor(typestore,_Modifier,"static");
  private static final Type _Modifier_virtual_0 
    = tf.constructor(typestore,_Modifier,"virtual");
  private static final Type _Modifier_typedef_0 
    = tf.constructor(typestore,_Modifier,"typedef");
  private static final Type _Modifier_const_0 
    = tf.constructor(typestore,_Modifier,"const");
  private static final Type _Modifier_register_0 
    = tf.constructor(typestore,_Modifier,"register");
  private static final Type _Modifier_private_0 
    = tf.constructor(typestore,_Modifier,"private");
  private static final Type _Modifier_signed_0 
    = tf.constructor(typestore,_Modifier,"signed");
  private static final Type _Modifier_restrict_0 
    = tf.constructor(typestore,_Modifier,"restrict");
  private static final Type _Modifier_long_0 
    = tf.constructor(typestore,_Modifier,"long");
  private static final Type _Modifier_volatile_0 
    = tf.constructor(typestore,_Modifier,"volatile");
  private static final Type _Modifier_short_0 
    = tf.constructor(typestore,_Modifier,"short");
  private static final Type _Modifier_inline_0 
    = tf.constructor(typestore,_Modifier,"inline");
  private static final Type _Modifier_imaginary_0 
    = tf.constructor(typestore,_Modifier,"imaginary");
  private static final Type _Modifier_constexpr_0 
    = tf.constructor(typestore,_Modifier,"constexpr");
  private static final Type _Modifier_longlong_0 
    = tf.constructor(typestore,_Modifier,"longlong");
  private static final Type _Modifier_explicit_0 
    = tf.constructor(typestore,_Modifier,"explicit");
  private static final Type _Modifier_captDefUnspecified_0 
    = tf.constructor(typestore,_Modifier,"captDefUnspecified");
  private static final Type _Modifier_unspecifiedInheritance_0 
    = tf.constructor(typestore,_Modifier,"unspecifiedInheritance");
  private static final Type _Modifier_pureVirtual_0 
    = tf.constructor(typestore,_Modifier,"pureVirtual");
  
  
  private static final Type _TypeSymbol_float_0 
    = tf.constructor(typestore,_TypeSymbol,"float");
  private static final Type _TypeSymbol_double_0 
    = tf.constructor(typestore,_TypeSymbol,"double");
  private static final Type _TypeSymbol_unspecified_0 
    = tf.constructor(typestore,_TypeSymbol,"unspecified");
  private static final Type _TypeSymbol_class_1 
    = tf.constructor(typestore,_TypeSymbol,"class",tf.sourceLocationType(),"decl");
  private static final Type _TypeSymbol_unknownMemberClass_2 
    = tf.constructor(typestore,_TypeSymbol,"unknownMemberClass",_TypeSymbol,"owner",tf.stringType(),"name");
  private static final Type _TypeSymbol_functionType_2 
    = tf.constructor(typestore,_TypeSymbol,"functionType",_TypeSymbol,"returnType",tf.listType(_TypeSymbol),"parameterTypes");
  private static final Type _TypeSymbol_problemType_0 
    = tf.constructor(typestore,_TypeSymbol,"problemType");
  private static final Type _TypeSymbol_functionTypeVarArgs_2 
    = tf.constructor(typestore,_TypeSymbol,"functionTypeVarArgs",_TypeSymbol,"returnType",tf.listType(_TypeSymbol),"parameterTypes");
  private static final Type _TypeSymbol_noType_0 
    = tf.constructor(typestore,_TypeSymbol,"noType");
  private static final Type _TypeSymbol_float128_0 
    = tf.constructor(typestore,_TypeSymbol,"float128");
  private static final Type _TypeSymbol_char16_0 
    = tf.constructor(typestore,_TypeSymbol,"char16");
  private static final Type _TypeSymbol_union_1 
    = tf.constructor(typestore,_TypeSymbol,"union",tf.sourceLocationType(),"decl");
  private static final Type _TypeSymbol_templateTypeParameter_2 
    = tf.constructor(typestore,_TypeSymbol,"templateTypeParameter",tf.stringType(),"ownerName",tf.stringType(),"name");
  private static final Type _TypeSymbol_typeOfDependentExpression_1 
    = tf.constructor(typestore,_TypeSymbol,"typeOfDependentExpression",tf.sourceLocationType(),"src");
  private static final Type _TypeSymbol_array_1 
    = tf.constructor(typestore,_TypeSymbol,"array",_TypeSymbol,"baseType");
  private static final Type _TypeSymbol_qualifierType_2 
    = tf.constructor(typestore,_TypeSymbol,"qualifierType",tf.listType(_TypeModifier),"modifiers",_TypeSymbol,"type");
  private static final Type _TypeSymbol_decimal32_0 
    = tf.constructor(typestore,_TypeSymbol,"decimal32");
  private static final Type _TypeSymbol_enumerationSpecialization_2 
    = tf.constructor(typestore,_TypeSymbol,"enumerationSpecialization",tf.sourceLocationType(),"specializedBinding",tf.listType(_TypeSymbol),"templateArguments");
  private static final Type _TypeSymbol_char32_0 
    = tf.constructor(typestore,_TypeSymbol,"char32");
  private static final Type _TypeSymbol_enumeration_1 
    = tf.constructor(typestore,_TypeSymbol,"enumeration",tf.sourceLocationType(),"decl");
  private static final Type _TypeSymbol_typeContainer_1 
    = tf.constructor(typestore,_TypeSymbol,"typeContainer",_TypeSymbol,"type");
  private static final Type _TypeSymbol_void_0 
    = tf.constructor(typestore,_TypeSymbol,"void");
  private static final Type _TypeSymbol_char_0 
    = tf.constructor(typestore,_TypeSymbol,"char");
  private static final Type _TypeSymbol_referenceType_1 
    = tf.constructor(typestore,_TypeSymbol,"referenceType",_TypeSymbol,"type");
  private static final Type _TypeSymbol_boolean_0 
    = tf.constructor(typestore,_TypeSymbol,"boolean");
  private static final Type _TypeSymbol_int128_0 
    = tf.constructor(typestore,_TypeSymbol,"int128");
  private static final Type _TypeSymbol_wchar_0 
    = tf.constructor(typestore,_TypeSymbol,"wchar");
  private static final Type _TypeSymbol_pointerType_2 
    = tf.constructor(typestore,_TypeSymbol,"pointerType",tf.listType(_TypeModifier),"modifiers",_TypeSymbol,"type");
  private static final Type _TypeSymbol_any_0 
    = tf.constructor(typestore,_TypeSymbol,"any");
  private static final Type _TypeSymbol_classSpecialization_2 
    = tf.constructor(typestore,_TypeSymbol,"classSpecialization",tf.sourceLocationType(),"decl",tf.listType(_TypeSymbol),"templateArguments");
  private static final Type _TypeSymbol_parameterPackType_1 
    = tf.constructor(typestore,_TypeSymbol,"parameterPackType",_TypeSymbol,"type");
  private static final Type _TypeSymbol_decimal64_0 
    = tf.constructor(typestore,_TypeSymbol,"decimal64");
  private static final Type _TypeSymbol_int_0 
    = tf.constructor(typestore,_TypeSymbol,"int");
  private static final Type _TypeSymbol_struct_1 
    = tf.constructor(typestore,_TypeSymbol,"struct",tf.listType(_TypeSymbol),"fields");
  private static final Type _TypeSymbol_deferredClassInstance_1 
    = tf.constructor(typestore,_TypeSymbol,"deferredClassInstance",tf.stringType(),"name");
  private static final Type _TypeSymbol_array_2 
    = tf.constructor(typestore,_TypeSymbol,"array",_TypeSymbol,"baseType",tf.integerType(),"size");
  private static final Type _TypeSymbol_nullPtr_0 
    = tf.constructor(typestore,_TypeSymbol,"nullPtr");
  private static final Type _TypeSymbol_decimal128_0 
    = tf.constructor(typestore,_TypeSymbol,"decimal128");
  private static final Type _TypeSymbol_basicType_2 
    = tf.constructor(typestore,_TypeSymbol,"basicType",tf.listType(_TypeModifier),"modifiers",_TypeSymbol,"baseType");
  private static final Type _TypeSymbol_problemBinding_0 
    = tf.constructor(typestore,_TypeSymbol,"problemBinding");
  
  
  private static final Type _Attribute_attribute_1 
    = tf.constructor(typestore,_Attribute,"attribute",tf.stringType(),"name");
  private static final Type _Attribute_attributeSpecifier_1 
    = tf.constructor(typestore,_Attribute,"attributeSpecifier",tf.listType(_Attribute),"attributes");
  private static final Type _Attribute_attribute_2 
    = tf.constructor(typestore,_Attribute,"attribute",tf.stringType(),"name",tf.stringType(),"argumentClause");
  
  
  private static final Type _TypeModifier_unsigned_0 
    = tf.constructor(typestore,_TypeModifier,"unsigned");
  private static final Type _TypeModifier_complex_0 
    = tf.constructor(typestore,_TypeModifier,"complex");
  private static final Type _TypeModifier_imaginary_0 
    = tf.constructor(typestore,_TypeModifier,"imaginary");
  private static final Type _TypeModifier_longlong_0 
    = tf.constructor(typestore,_TypeModifier,"longlong");
  private static final Type _TypeModifier_const_0 
    = tf.constructor(typestore,_TypeModifier,"const");
  private static final Type _TypeModifier_static_0 
    = tf.constructor(typestore,_TypeModifier,"static");
  private static final Type _TypeModifier_short_0 
    = tf.constructor(typestore,_TypeModifier,"short");
  private static final Type _TypeModifier_volatile_0 
    = tf.constructor(typestore,_TypeModifier,"volatile");
  private static final Type _TypeModifier_long_0 
    = tf.constructor(typestore,_TypeModifier,"long");
  private static final Type _TypeModifier_restrict_0 
    = tf.constructor(typestore,_TypeModifier,"restrict");
  private static final Type _TypeModifier_signed_0 
    = tf.constructor(typestore,_TypeModifier,"signed");
  
   
  
  public IConstructor Declarator_functionDeclarator(IList $attributes, IList $pointerOperators, IList $modifiers, IConstructor $name, IList $parameters, IList $virtSpecifiers, IConstructor $trailingReturnType, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
      
    if (!$trailingReturnType.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $trailingReturnType.getType() + " for $trailingReturnType:" + $trailingReturnType);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclarator_7 , $attributes, $pointerOperators, $modifiers, $name, $parameters, $virtSpecifiers, $trailingReturnType).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_declarator(IList $attributes, IList $pointerOperators, IConstructor $name, IConstructor $initializer, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_declarator_4 , $attributes, $pointerOperators, $name, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclaratorNoexcept(IList $attributes, IList $pointerOperators, IList $modifiers, IConstructor $name, IList $parameters, IList $virtSpecifiers, IConstructor $noexceptExpression, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
      
    if (!$noexceptExpression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $noexceptExpression.getType() + " for $noexceptExpression:" + $noexceptExpression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclaratorNoexcept_7 , $attributes, $pointerOperators, $modifiers, $name, $parameters, $virtSpecifiers, $noexceptExpression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_arrayDeclarator(IList $attributes, IList $pointerOperators, IConstructor $name, IList $arrayModifier, IConstructor $initializer, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$arrayModifier.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arrayModifier.getType() + " for $arrayModifier:" + $arrayModifier);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_arrayDeclarator_5 , $attributes, $pointerOperators, $name, $arrayModifier, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_fieldDeclarator(IList $attributes, IList $pointerOperators, IConstructor $name, IConstructor $bitFieldSize, IConstructor $initializer, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$bitFieldSize.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $bitFieldSize.getType() + " for $bitFieldSize:" + $bitFieldSize);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_fieldDeclarator_5 , $attributes, $pointerOperators, $name, $bitFieldSize, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_arrayDeclaratorNested(IList $attributes, IList $pointerOperators, IConstructor $declarator, IList $arrayModifier, IConstructor $initializer, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$arrayModifier.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arrayModifier.getType() + " for $arrayModifier:" + $arrayModifier);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_arrayDeclaratorNested_5 , $attributes, $pointerOperators, $declarator, $arrayModifier, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclaratorWithES(IList $attributes, IList $pointerOperators, IList $modifiers, IConstructor $name, IList $parameters, IList $virtSpecifiers, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclaratorWithES_6 , $attributes, $pointerOperators, $modifiers, $name, $parameters, $virtSpecifiers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclaratorNested(IList $attributes, IList $pointerOperators, IList $modifiers, IConstructor $declarator, IList $parameters, IList $virtSpecifiers, IConstructor $initializer, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclaratorNested_7 , $attributes, $pointerOperators, $modifiers, $declarator, $parameters, $virtSpecifiers, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclarator(IList $attributes, IList $pointerOperators, IConstructor $name, IList $parameters, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclarator_4 , $attributes, $pointerOperators, $name, $parameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclaratorWithES(IList $attributes, IList $pointerOperators, IList $modifiers, IConstructor $name, IList $parameters, IList $virtSpecifiers, IList $exceptionSpecification, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
      
    if (!$exceptionSpecification.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $exceptionSpecification.getType() + " for $exceptionSpecification:" + $exceptionSpecification);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclaratorWithES_7 , $attributes, $pointerOperators, $modifiers, $name, $parameters, $virtSpecifiers, $exceptionSpecification).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclarator(IList $attributes, IList $pointerOperators, IList $modifiers, IConstructor $name, IList $parameters, IList $virtSpecifiers, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclarator_6 , $attributes, $pointerOperators, $modifiers, $name, $parameters, $virtSpecifiers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_arrayDeclarator(IList $attributes, IList $pointerOperators, IConstructor $name, IList $arrayModifier, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$arrayModifier.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arrayModifier.getType() + " for $arrayModifier:" + $arrayModifier);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_arrayDeclarator_4 , $attributes, $pointerOperators, $name, $arrayModifier).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_fieldDeclarator(IList $attributes, IList $pointerOperators, IConstructor $name, IConstructor $bitFieldSize, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$bitFieldSize.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $bitFieldSize.getType() + " for $bitFieldSize:" + $bitFieldSize);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_fieldDeclarator_4 , $attributes, $pointerOperators, $name, $bitFieldSize).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_missingDeclarator(ISourceLocation $loc, ISourceLocation $decl) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_missingDeclarator_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_declarator(IList $attributes, IList $pointerOperators, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_declarator_3 , $attributes, $pointerOperators, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_arrayDeclaratorNested(IList $attributes, IList $pointerOperators, IConstructor $declarator, IList $arrayModifier, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$arrayModifier.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arrayModifier.getType() + " for $arrayModifier:" + $arrayModifier);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_arrayDeclaratorNested_4 , $attributes, $pointerOperators, $declarator, $arrayModifier).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclaratorNested(IList $attributes, IList $pointerOperators, IList $modifiers, IConstructor $declarator, IList $parameters, IList $virtSpecifiers, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclaratorNested_6 , $attributes, $pointerOperators, $modifiers, $declarator, $parameters, $virtSpecifiers).asWithKeywordParameters().setParameters(kwParams);
  }
    
  
  public IConstructor DeclSpecifier_union(IList $attributes, IList $modifiers, IConstructor $name, IList $baseSpecifiers, IList $members, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$baseSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $baseSpecifiers.getType() + " for $baseSpecifiers:" + $baseSpecifiers);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_union_5 , $attributes, $modifiers, $name, $baseSpecifiers, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_struct(IList $modifiers, IConstructor $name, IList $members, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_struct_3 , $modifiers, $name, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_declSpecifier(IList $attributes, IList $modifiers, IConstructor $type, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$type.getType().isSubtypeOf(_Type)) {
      throw new IllegalArgumentException("Expected " + _Type + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_DeclSpecifier_declSpecifier_3 , $attributes, $modifiers, $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_structFinal(IList $attributes, IList $modifiers, IConstructor $name, IList $baseSpecifiers, IList $members, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$baseSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $baseSpecifiers.getType() + " for $baseSpecifiers:" + $baseSpecifiers);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_structFinal_5 , $attributes, $modifiers, $name, $baseSpecifiers, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_classFinal(IList $attributes, IList $modifiers, IConstructor $name, IList $baseSpecifiers, IList $members, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$baseSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $baseSpecifiers.getType() + " for $baseSpecifiers:" + $baseSpecifiers);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_classFinal_5 , $attributes, $modifiers, $name, $baseSpecifiers, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_etsStruct(IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_etsStruct_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_class(IList $attributes, IList $modifiers, IConstructor $name, IList $baseSpecifiers, IList $members, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$baseSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $baseSpecifiers.getType() + " for $baseSpecifiers:" + $baseSpecifiers);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_class_5 , $attributes, $modifiers, $name, $baseSpecifiers, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_etsClass(IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_etsClass_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enum(IList $attributes, IList $modifiers, IConstructor $baseType, IConstructor $name, IList $enumerators, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$baseType.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$enumerators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $enumerators.getType() + " for $enumerators:" + $enumerators);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enum_5 , $attributes, $modifiers, $baseType, $name, $enumerators).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_union(IList $modifiers, IConstructor $name, IList $members, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_union_3 , $modifiers, $name, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_namedTypeSpecifier(IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_namedTypeSpecifier_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_etsUnion(IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_etsUnion_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_etsEnum(IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_etsEnum_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enumScoped(IList $attributes, IList $modifiers, IConstructor $baseType, IConstructor $name, IList $enumerators, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$baseType.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$enumerators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $enumerators.getType() + " for $enumerators:" + $enumerators);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enumScoped_5 , $attributes, $modifiers, $baseType, $name, $enumerators).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_unionFinal(IList $attributes, IList $modifiers, IConstructor $name, IList $baseSpecifiers, IList $members, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$baseSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $baseSpecifiers.getType() + " for $baseSpecifiers:" + $baseSpecifiers);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_unionFinal_5 , $attributes, $modifiers, $name, $baseSpecifiers, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enumScopedOpaque(IList $attributes, IList $modifiers, IConstructor $baseType, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$baseType.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enumScopedOpaque_4 , $attributes, $modifiers, $baseType, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_class(IList $modifiers, IConstructor $name, IList $members, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_class_3 , $modifiers, $name, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_msThrowEllipsis(ISourceLocation $loc, ISourceLocation $decl) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_msThrowEllipsis_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enum(IList $attributes, IList $modifiers, IConstructor $name, IList $enumerators, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$enumerators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $enumerators.getType() + " for $enumerators:" + $enumerators);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enum_4 , $attributes, $modifiers, $name, $enumerators).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_declSpecifier(IList $attributes, IList $modifiers, IConstructor $type, IConstructor $expression, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$type.getType().isSubtypeOf(_Type)) {
      throw new IllegalArgumentException("Expected " + _Type + " but got " + $type.getType() + " for $type:" + $type);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_DeclSpecifier_declSpecifier_4 , $attributes, $modifiers, $type, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enumScopedOpaque(IList $attributes, IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enumScopedOpaque_3 , $attributes, $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enumOpaque(IList $attributes, IList $modifiers, IConstructor $baseType, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$baseType.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enumOpaque_4 , $attributes, $modifiers, $baseType, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enumScoped(IList $attributes, IList $modifiers, IConstructor $name, IList $enumerators, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$enumerators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $enumerators.getType() + " for $enumerators:" + $enumerators);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enumScoped_4 , $attributes, $modifiers, $name, $enumerators).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_struct(IList $attributes, IList $modifiers, IConstructor $name, IList $baseSpecifiers, IList $members, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$baseSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $baseSpecifiers.getType() + " for $baseSpecifiers:" + $baseSpecifiers);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_struct_5 , $attributes, $modifiers, $name, $baseSpecifiers, $members).asWithKeywordParameters().setParameters(kwParams);
  }
    
  
  public IConstructor Declaration_tttParameter(IList $nestedParameters, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$nestedParameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $nestedParameters.getType() + " for $nestedParameters:" + $nestedParameters);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_tttParameter_2 , $nestedParameters, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_namespaceDefinitionInline(IList $attributes, IConstructor $name, IList $declarations, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$declarations.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $declarations.getType() + " for $declarations:" + $declarations);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_namespaceDefinitionInline_3 , $attributes, $name, $declarations).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_functionDefinition(IConstructor $returnSpec, IConstructor $declarator, IConstructor $body, ISourceLocation $loc) {
      
    if (!$returnSpec.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $returnSpec.getType() + " for $returnSpec:" + $returnSpec);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_functionDefinition_3 , $returnSpec, $declarator, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_explicitTemplateSpecialization(IConstructor $declaration, ISourceLocation $loc) {
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_explicitTemplateSpecialization_1 , $declaration).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_functionDefinition(IList $attributes, IConstructor $declSpecifier, IConstructor $declarator, IList $memberInitializer, IConstructor $body, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$memberInitializer.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $memberInitializer.getType() + " for $memberInitializer:" + $memberInitializer);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_functionDefinition_5 , $attributes, $declSpecifier, $declarator, $memberInitializer, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_baseSpecifier(IList $modifiers, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_baseSpecifier_1 , $modifiers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_reference(IList $attributes, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_reference_1 , $attributes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_namespaceAlias(IConstructor $alias, IConstructor $mapping, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$alias.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $alias.getType() + " for $alias:" + $alias);
    }
      
    if (!$mapping.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $mapping.getType() + " for $mapping:" + $mapping);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_namespaceAlias_2 , $alias, $mapping).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_enumerator(IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_enumerator_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_parameter(IConstructor $declSpecifier, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_parameter_1 , $declSpecifier).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_explicitTemplateInstantiation(IConstructor $modifier, IConstructor $declaration, ISourceLocation $loc) {
      
    if (!$modifier.getType().isSubtypeOf(_Modifier)) {
      throw new IllegalArgumentException("Expected " + _Modifier + " but got " + $modifier.getType() + " for $modifier:" + $modifier);
    }
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_explicitTemplateInstantiation_2 , $modifier, $declaration).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_sttClass(IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_sttClass_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_virtSpecifier(IConstructor $modifier, ISourceLocation $loc) {
      
    if (!$modifier.getType().isSubtypeOf(_Modifier)) {
      throw new IllegalArgumentException("Expected " + _Modifier + " but got " + $modifier.getType() + " for $modifier:" + $modifier);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_virtSpecifier_1 , $modifier).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_pointerToMember(IList $attributes, IList $modifiers, IConstructor $nestedName, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$nestedName.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $nestedName.getType() + " for $nestedName:" + $nestedName);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_pointerToMember_3 , $attributes, $modifiers, $nestedName).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_staticAssert(IConstructor $condition, IConstructor $message, ISourceLocation $loc) {
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$message.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $message.getType() + " for $message:" + $message);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_staticAssert_2 , $condition, $message).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_functionWithTryBlockDefinition(IList $attributes, IConstructor $declSpecifier, IConstructor $declarator, IList $memberInitializers, IConstructor $sbody, IList $catchHandlers, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$memberInitializers.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $memberInitializers.getType() + " for $memberInitializers:" + $memberInitializers);
    }
      
    if (!$sbody.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $sbody.getType() + " for $sbody:" + $sbody);
    }
      
    if (!$catchHandlers.getType().isSubtypeOf(tf.listType(_Statement))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Statement) + " but got " + $catchHandlers.getType() + " for $catchHandlers:" + $catchHandlers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_functionWithTryBlockDefinition_6 , $attributes, $declSpecifier, $declarator, $memberInitializers, $sbody, $catchHandlers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_visibilityLabel(IConstructor $visibility, ISourceLocation $loc) {
      
    if (!$visibility.getType().isSubtypeOf(_Modifier)) {
      throw new IllegalArgumentException("Expected " + _Modifier + " but got " + $visibility.getType() + " for $visibility:" + $visibility);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_visibilityLabel_1 , $visibility).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_namespaceDefinition(IList $attributes, IConstructor $name, IList $declarations, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$declarations.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $declarations.getType() + " for $declarations:" + $declarations);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_namespaceDefinition_3 , $attributes, $name, $declarations).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_translationUnit(IList $declarations, ISourceLocation $loc) {
      
    if (!$declarations.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $declarations.getType() + " for $declarations:" + $declarations);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_translationUnit_1 , $declarations).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_enumerator(IConstructor $name, IConstructor $value, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$value.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $value.getType() + " for $value:" + $value);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_enumerator_2 , $name, $value).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_pointer(IList $attributes, IList $modifiers, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_pointer_2 , $attributes, $modifiers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_sttClass(IConstructor $name, IConstructor $defaultType, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$defaultType.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $defaultType.getType() + " for $defaultType:" + $defaultType);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_sttClass_2 , $name, $defaultType).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_parameter(IConstructor $declSpecifier, IConstructor $declarator, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_parameter_2 , $declSpecifier, $declarator).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_baseSpecifier(IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_baseSpecifier_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_problemDeclaration(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_problemDeclaration_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_varArgs(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_varArgs_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_template(IList $parameters, IConstructor $declaration, ISourceLocation $loc) {
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_template_2 , $parameters, $declaration).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_alias(IList $attributes, IConstructor $alias, IConstructor $mappingTypeId, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$alias.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $alias.getType() + " for $alias:" + $alias);
    }
      
    if (!$mappingTypeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $mappingTypeId.getType() + " for $mappingTypeId:" + $mappingTypeId);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_alias_3 , $attributes, $alias, $mappingTypeId).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_deletedFunctionDefinition(IList $attributes, IConstructor $declSpecifier, IList $memberInitializer, IConstructor $declarator, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$memberInitializer.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $memberInitializer.getType() + " for $memberInitializer:" + $memberInitializer);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_deletedFunctionDefinition_4 , $attributes, $declSpecifier, $memberInitializer, $declarator).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_sttTypename(IConstructor $name, IConstructor $defaultType, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$defaultType.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $defaultType.getType() + " for $defaultType:" + $defaultType);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_sttTypename_2 , $name, $defaultType).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_usingDirective(IList $attributes, IConstructor $qualifiedName, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$qualifiedName.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $qualifiedName.getType() + " for $qualifiedName:" + $qualifiedName);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_usingDirective_2 , $attributes, $qualifiedName).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_explicitTemplateInstantiation(IConstructor $declaration, ISourceLocation $loc) {
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_explicitTemplateInstantiation_1 , $declaration).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_linkageSpecification(String $literal, IList $declarations, ISourceLocation $loc) {
      
    if (!vf.string($literal).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($literal).getType() + " for vf.string($literal):" + vf.string($literal));
    }
      
    if (!$declarations.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $declarations.getType() + " for $declarations:" + $declarations);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_linkageSpecification_2 , vf.string($literal), $declarations).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_simpleDeclaration(IList $attributes, IConstructor $declSpecifier, IList $declarators, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$declarators.getType().isSubtypeOf(tf.listType(_Declarator))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declarator) + " but got " + $declarators.getType() + " for $declarators:" + $declarators);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_simpleDeclaration_3 , $attributes, $declSpecifier, $declarators).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_defaultedFunctionDefinition(IList $attributes, IConstructor $declSpecifier, IList $memberInitializer, IConstructor $declarator, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$memberInitializer.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $memberInitializer.getType() + " for $memberInitializer:" + $memberInitializer);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_defaultedFunctionDefinition_4 , $attributes, $declSpecifier, $memberInitializer, $declarator).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_sttTypename(IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_sttTypename_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_usingDeclaration(IList $attributes, IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_usingDeclaration_3 , $attributes, $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_asmDeclaration(String $assembly, ISourceLocation $loc) {
      
    if (!vf.string($assembly).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($assembly).getType() + " for vf.string($assembly):" + vf.string($assembly));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_asmDeclaration_1 , vf.string($assembly)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_rvalueReference(IList $attributes, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_rvalueReference_1 , $attributes).asWithKeywordParameters().setParameters(kwParams);
  }
    
  
  public IConstructor Expression_empty(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_empty_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_arrayDesignator(IConstructor $subscript, ISourceLocation $loc) {
      
    if (!$subscript.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $subscript.getType() + " for $subscript:" + $subscript);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_arrayDesignator_1 , $subscript).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_sizeofParameterPack(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_sizeofParameterPack_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_minusAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_minusAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_equals(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_equals_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_charConstant(String $value, ISourceLocation $loc, IConstructor $typ) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_charConstant_1 , vf.string($value)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_typeid(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_typeid_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_true(ISourceLocation $loc, IConstructor $typ) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_true_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_labelReference(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_labelReference_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_typeId(IConstructor $declSpecifier, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_typeId_1 , $declSpecifier).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_minus(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_minus_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_greaterThan(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_greaterThan_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_lessEqual(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_lessEqual_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_arrayModifier(IList $attributes, IConstructor $constExpression, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$constExpression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $constExpression.getType() + " for $constExpression:" + $constExpression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_arrayModifier_2 , $attributes, $constExpression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_globalVectoredDelete(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_globalVectoredDelete_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_functionCall(IConstructor $functionName, IList $arguments, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$functionName.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $functionName.getType() + " for $functionName:" + $functionName);
    }
      
    if (!$arguments.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arguments.getType() + " for $arguments:" + $arguments);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_functionCall_2 , $functionName, $arguments).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_binaryXor(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_binaryXor_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_amper(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_amper_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_plus(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_plus_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_stringLiteral(String $value, ISourceLocation $loc, IConstructor $typ) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_stringLiteral_1 , vf.string($value)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_shiftRight(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_shiftRight_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_captureThisPtr(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_captureThisPtr_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_greaterEqual(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_greaterEqual_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_lessThan(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_lessThan_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_arraySubscriptExpression(IConstructor $array, IConstructor $argument, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$array.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $array.getType() + " for $array:" + $array);
    }
      
    if (!$argument.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $argument.getType() + " for $argument:" + $argument);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_arraySubscriptExpression_2 , $array, $argument).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_divide(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_divide_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_fieldReferencePointerDeref(IConstructor $fieldOnwer, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl, IConstructor $typ) {
      
    if (!$fieldOnwer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $fieldOnwer.getType() + " for $fieldOnwer:" + $fieldOnwer);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_fieldReferencePointerDeref_2 , $fieldOnwer, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_uuidof(IConstructor $expression, ISourceLocation $loc) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_uuidof_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_star(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_star_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_conversionName(String $value, IConstructor $typeId, ISourceLocation $loc, IConstructor $typ) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_conversionName_2 , vf.string($value), $typeId).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_typeId(IConstructor $declSpecifier, IConstructor $abstractDeclarator, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$abstractDeclarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $abstractDeclarator.getType() + " for $abstractDeclarator:" + $abstractDeclarator);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_typeId_2 , $declSpecifier, $abstractDeclarator).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_shiftLeftAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_shiftLeftAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_not(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_not_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_idExpression(IConstructor $name, ISourceLocation $loc, ISourceLocation $decl, IConstructor $typ) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_idExpression_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_fieldReference(IConstructor $fieldOwner, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl, IConstructor $typ) {
      
    if (!$fieldOwner.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $fieldOwner.getType() + " for $fieldOwner:" + $fieldOwner);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_fieldReference_2 , $fieldOwner, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_initializerList(IList $clauses, ISourceLocation $loc) {
      
    if (!$clauses.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $clauses.getType() + " for $clauses:" + $clauses);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_initializerList_1 , $clauses).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_alignOf(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_alignOf_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_nullptr(ISourceLocation $loc, IConstructor $typ) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_nullptr_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_throw(ISourceLocation $loc, IConstructor $typ) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_throw_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_modulo(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_modulo_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_binaryAnd(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_binaryAnd_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_dynamicCast(IConstructor $typeId, IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_dynamicCast_2 , $typeId, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_ellipses(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_ellipses_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_simpleTypeConstructor(IConstructor $declSpecifier, IConstructor $initializer, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_simpleTypeConstructor_2 , $declSpecifier, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_globalNew(IConstructor $typeId, IConstructor $initializer, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_globalNew_2 , $typeId, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_qualifiedName(IList $qualifiers, IConstructor $lastName, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$qualifiers.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $qualifiers.getType() + " for $qualifiers:" + $qualifiers);
    }
      
    if (!$lastName.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lastName.getType() + " for $lastName:" + $lastName);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Expression_qualifiedName_2 , $qualifiers, $lastName).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_cast(IConstructor $typeId, IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_cast_2 , $typeId, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_multiplyAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_multiplyAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_sizeof(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_sizeof_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_false(ISourceLocation $loc, IConstructor $typ) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_false_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_tilde(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_tilde_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_binaryOrAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_binaryOrAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_notEquals(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_notEquals_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_arrayRangeDesignator(IConstructor $rangeFloor, IConstructor $rangeCeiling, ISourceLocation $loc) {
      
    if (!$rangeFloor.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rangeFloor.getType() + " for $rangeFloor:" + $rangeFloor);
    }
      
    if (!$rangeCeiling.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rangeCeiling.getType() + " for $rangeCeiling:" + $rangeCeiling);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_arrayRangeDesignator_2 , $rangeFloor, $rangeCeiling).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_min(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_min_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_reinterpretCast(IConstructor $typeId, IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_reinterpretCast_2 , $typeId, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_captureByRef(IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Expression_captureByRef_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_constructorInitializer(IList $arguments, ISourceLocation $loc) {
      
    if (!$arguments.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arguments.getType() + " for $arguments:" + $arguments);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_constructorInitializer_1 , $arguments).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_plus(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_plus_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_noexcept(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_noexcept_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_minus(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_minus_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_new(IConstructor $typeId, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_new_1 , $typeId).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_nyi(String $raw, ISourceLocation $loc) {
      
    if (!vf.string($raw).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($raw).getType() + " for vf.string($raw):" + vf.string($raw));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_nyi_1 , vf.string($raw)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_assign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_assign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_name(String $value, ISourceLocation $loc) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_name_1 , vf.string($value)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_postfixDecr(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_postfixDecr_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_this(ISourceLocation $loc, IConstructor $typ) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_this_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_logicalAnd(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_logicalAnd_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_throw(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_throw_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_prefixIncr(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_prefixIncr_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_globalNew(IConstructor $typeId, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_globalNew_1 , $typeId).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_pmArrow(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_pmArrow_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_pmDot(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_pmDot_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_bracketed(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_bracketed_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_logicalOr(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_logicalOr_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_equalsInitializer(IConstructor $initializer, ISourceLocation $loc) {
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_equalsInitializer_1 , $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_constructorChainInitializer(IConstructor $name, IConstructor $initializer, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Expression_constructorChainInitializer_2 , $name, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_integerLiteral(IValue $number, ISourceLocation $loc) {
      
    if (!$number.getType().isSubtypeOf(tf.integerType())) {
      throw new IllegalArgumentException("Expected " + tf.integerType() + " but got " + $number.getType() + " for $number:" + $number);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_integerLiteral_1 , $number).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_operatorName(String $value, ISourceLocation $loc) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_operatorName_1 , vf.string($value)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_shiftRightAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_shiftRightAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_constCast(IConstructor $typeId, IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_constCast_2 , $typeId, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_binaryXorAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_binaryXorAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_prefixDecr(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_prefixDecr_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_plusAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_plusAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_lambda(IConstructor $captureDefault, IList $captures, IConstructor $declarator, IConstructor $body, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$captureDefault.getType().isSubtypeOf(_Modifier)) {
      throw new IllegalArgumentException("Expected " + _Modifier + " but got " + $captureDefault.getType() + " for $captureDefault:" + $captureDefault);
    }
      
    if (!$captures.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $captures.getType() + " for $captures:" + $captures);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_lambda_4 , $captureDefault, $captures, $declarator, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_shiftLeft(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_shiftLeft_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_new(IConstructor $typeId, IConstructor $initializer, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_new_2 , $typeId, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_divideAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_divideAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_newWithArgs(IList $arguments, IConstructor $typeId, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$arguments.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arguments.getType() + " for $arguments:" + $arguments);
    }
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_newWithArgs_2 , $arguments, $typeId).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_designatedInitializer(IList $designators, IConstructor $operand, ISourceLocation $loc) {
      
    if (!$designators.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $designators.getType() + " for $designators:" + $designators);
    }
      
    if (!$operand.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $operand.getType() + " for $operand:" + $operand);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_designatedInitializer_2 , $designators, $operand).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_problemExpression(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_problemExpression_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_abstractEmptyName(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_abstractEmptyName_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_vectoredDelete(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_vectoredDelete_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_integerConstant(String $value, ISourceLocation $loc, IConstructor $typ) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_integerConstant_1 , vf.string($value)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_staticCast(IConstructor $typeId, IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_staticCast_2 , $typeId, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_packExpansion(IConstructor $pattern, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$pattern.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $pattern.getType() + " for $pattern:" + $pattern);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_packExpansion_1 , $pattern).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_binaryAndAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_binaryAndAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_conditional(IConstructor $condition, IConstructor $positive, IConstructor $negative, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$positive.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $positive.getType() + " for $positive:" + $positive);
    }
      
    if (!$negative.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $negative.getType() + " for $negative:" + $negative);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_conditional_3 , $condition, $positive, $negative).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_moduloAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_moduloAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_globalDelete(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_globalDelete_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_max(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_max_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_binaryOr(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_binaryOr_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_multiply(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_multiply_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_floatConstant(String $value, ISourceLocation $loc, IConstructor $typ) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_floatConstant_1 , vf.string($value)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_globalNewWithArgs(IList $arguments, IConstructor $typeId, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$arguments.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arguments.getType() + " for $arguments:" + $arguments);
    }
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_globalNewWithArgs_2 , $arguments, $typeId).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_fieldDesignator(IConstructor $fieldName, ISourceLocation $loc) {
      
    if (!$fieldName.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $fieldName.getType() + " for $fieldName:" + $fieldName);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_fieldDesignator_1 , $fieldName).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_newWithArgs(IList $arguments, IConstructor $typeId, IConstructor $initializer, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$arguments.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arguments.getType() + " for $arguments:" + $arguments);
    }
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_newWithArgs_3 , $arguments, $typeId, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_arrayModifier(IList $attributes, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_arrayModifier_1 , $attributes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_postfixIncr(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_postfixIncr_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_capture(IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Expression_capture_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_globalNewWithArgs(IList $arguments, IConstructor $typeId, IConstructor $initializer, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$arguments.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arguments.getType() + " for $arguments:" + $arguments);
    }
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_globalNewWithArgs_3 , $arguments, $typeId, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_expressionList(IList $expressions, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expressions.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $expressions.getType() + " for $expressions:" + $expressions);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_expressionList_1 , $expressions).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_delete(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_delete_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_templateId(IConstructor $name, IList $argumentTypes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$argumentTypes.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $argumentTypes.getType() + " for $argumentTypes:" + $argumentTypes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Expression_templateId_2 , $name, $argumentTypes).asWithKeywordParameters().setParameters(kwParams);
  }
    
  
  public IConstructor Type_wchar_t(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_wchar_t_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_decltype(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_decltype_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_decimal128(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_decimal128_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_nullptr(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_nullptr_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_int128(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_int128_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_classType(IConstructor $name, ISourceLocation $loc) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_classType_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_unionType(IConstructor $name, ISourceLocation $loc) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_unionType_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_basicType(IConstructor $type, IList $modifiers, ISourceLocation $loc) {
      
    if (!$type.getType().isSubtypeOf(_Type)) {
      throw new IllegalArgumentException("Expected " + _Type + " but got " + $type.getType() + " for $type:" + $type);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_basicType_2 , $type, $modifiers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_char(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_char_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_unspecified(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_unspecified_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_arrayType(IConstructor $type, IValue $size, ISourceLocation $loc) {
      
    if (!$type.getType().isSubtypeOf(_Type)) {
      throw new IllegalArgumentException("Expected " + _Type + " but got " + $type.getType() + " for $type:" + $type);
    }
      
    if (!$size.getType().isSubtypeOf(tf.integerType())) {
      throw new IllegalArgumentException("Expected " + tf.integerType() + " but got " + $size.getType() + " for $size:" + $size);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_arrayType_2 , $type, $size).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_float128(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_float128_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_float(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_float_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_integer(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_integer_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_char32_t(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_char32_t_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_bool(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_bool_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_decimal64(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_decimal64_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_auto(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_auto_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_decimal32(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_decimal32_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_char16_t(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_char16_t_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_typeof(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_typeof_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_double(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_double_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_structType(IConstructor $name, ISourceLocation $loc) {
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_structType_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_void(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_void_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
    
  
  public IConstructor Statement_goto(IList $attributes, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Statement_goto_2 , $attributes, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_for(IList $attributes, IConstructor $sInitializer, IConstructor $condition, IConstructor $iteration, IConstructor $body, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$sInitializer.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $sInitializer.getType() + " for $sInitializer:" + $sInitializer);
    }
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$iteration.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $iteration.getType() + " for $iteration:" + $iteration);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_for_5 , $attributes, $sInitializer, $condition, $iteration, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_label(IList $attributes, IConstructor $name, IConstructor $nestedStatement, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$name.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$nestedStatement.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $nestedStatement.getType() + " for $nestedStatement:" + $nestedStatement);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Statement_label_3 , $attributes, $name, $nestedStatement).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_while(IList $attributes, IConstructor $condition, IConstructor $body, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_while_3 , $attributes, $condition, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_ifNotExists(IList $attributes, IConstructor $condition, IConstructor $thenClause, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$thenClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $thenClause.getType() + " for $thenClause:" + $thenClause);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_ifNotExists_3 , $attributes, $condition, $thenClause).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_ifWithDecl(IList $attributes, IConstructor $conditionDeclaration, IConstructor $thenClause, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$conditionDeclaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $conditionDeclaration.getType() + " for $conditionDeclaration:" + $conditionDeclaration);
    }
      
    if (!$thenClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $thenClause.getType() + " for $thenClause:" + $thenClause);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_ifWithDecl_3 , $attributes, $conditionDeclaration, $thenClause).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_break(IList $attributes, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_break_1 , $attributes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_tryExcept(IList $attributes, IConstructor $tryBody, IConstructor $exceptFilter, IConstructor $exceptBody, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$tryBody.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $tryBody.getType() + " for $tryBody:" + $tryBody);
    }
      
    if (!$exceptFilter.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $exceptFilter.getType() + " for $exceptFilter:" + $exceptFilter);
    }
      
    if (!$exceptBody.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $exceptBody.getType() + " for $exceptBody:" + $exceptBody);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_tryExcept_4 , $attributes, $tryBody, $exceptFilter, $exceptBody).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_problem(String $raw, ISourceLocation $loc) {
      
    if (!vf.string($raw).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($raw).getType() + " for vf.string($raw):" + vf.string($raw));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_problem_1 , vf.string($raw)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_continue(IList $attributes, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_continue_1 , $attributes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_switchWithDecl(IList $attributes, IConstructor $controllerDeclaration, IConstructor $body, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$controllerDeclaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $controllerDeclaration.getType() + " for $controllerDeclaration:" + $controllerDeclaration);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_switchWithDecl_3 , $attributes, $controllerDeclaration, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_ifWithDecl(IList $attributes, IConstructor $conditionDeclaration, IConstructor $thenClause, IConstructor $elseClause, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$conditionDeclaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $conditionDeclaration.getType() + " for $conditionDeclaration:" + $conditionDeclaration);
    }
      
    if (!$thenClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $thenClause.getType() + " for $thenClause:" + $thenClause);
    }
      
    if (!$elseClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $elseClause.getType() + " for $elseClause:" + $elseClause);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_ifWithDecl_4 , $attributes, $conditionDeclaration, $thenClause, $elseClause).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_expressionStatement(IList $attributes, IConstructor $expression, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_expressionStatement_2 , $attributes, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_ifExists(IList $attributes, IConstructor $condition, IConstructor $thenClause, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$thenClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $thenClause.getType() + " for $thenClause:" + $thenClause);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_ifExists_3 , $attributes, $condition, $thenClause).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_defaultCase(IList $attributes, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_defaultCase_1 , $attributes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_return(IList $attributes, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_return_1 , $attributes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_rangeBasedFor(IList $attributes, IConstructor $declaration, IConstructor $initializer, IConstructor $body, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_rangeBasedFor_4 , $attributes, $declaration, $initializer, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_whileWithDecl(IList $attributes, IConstructor $conditionDeclaration, IConstructor $body, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$conditionDeclaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $conditionDeclaration.getType() + " for $conditionDeclaration:" + $conditionDeclaration);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_whileWithDecl_3 , $attributes, $conditionDeclaration, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_switch(IList $attributes, IConstructor $controller, IConstructor $body, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$controller.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $controller.getType() + " for $controller:" + $controller);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_switch_3 , $attributes, $controller, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_do(IList $attributes, IConstructor $body, IConstructor $condition, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_do_3 , $attributes, $body, $condition).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_if(IList $attributes, IConstructor $condition, IConstructor $thenClause, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$thenClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $thenClause.getType() + " for $thenClause:" + $thenClause);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_if_3 , $attributes, $condition, $thenClause).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_tryBlock(IList $attributes, IConstructor $tryBody, IList $catchHandlers, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$tryBody.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $tryBody.getType() + " for $tryBody:" + $tryBody);
    }
      
    if (!$catchHandlers.getType().isSubtypeOf(tf.listType(_Statement))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Statement) + " but got " + $catchHandlers.getType() + " for $catchHandlers:" + $catchHandlers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_tryBlock_3 , $attributes, $tryBody, $catchHandlers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_forWithDecl(IList $attributes, IConstructor $sInitializer, IConstructor $conditionDeclaration, IConstructor $iteration, IConstructor $body, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$sInitializer.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $sInitializer.getType() + " for $sInitializer:" + $sInitializer);
    }
      
    if (!$conditionDeclaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $conditionDeclaration.getType() + " for $conditionDeclaration:" + $conditionDeclaration);
    }
      
    if (!$iteration.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $iteration.getType() + " for $iteration:" + $iteration);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_forWithDecl_5 , $attributes, $sInitializer, $conditionDeclaration, $iteration, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_tryFinally(IList $attributes, IConstructor $tryBody, IConstructor $finallyBody, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$tryBody.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $tryBody.getType() + " for $tryBody:" + $tryBody);
    }
      
    if (!$finallyBody.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $finallyBody.getType() + " for $finallyBody:" + $finallyBody);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_tryFinally_3 , $attributes, $tryBody, $finallyBody).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_nullStatement(IList $attributes, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_nullStatement_1 , $attributes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_declarationStatement(IList $attributes, IConstructor $declaration, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_declarationStatement_2 , $attributes, $declaration).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_asm(String $assembly, ISourceLocation $loc) {
      
    if (!vf.string($assembly).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($assembly).getType() + " for vf.string($assembly):" + vf.string($assembly));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_asm_1 , vf.string($assembly)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_catchAll(IList $attributes, IConstructor $body, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_catchAll_2 , $attributes, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_compoundStatement(IList $attributes, IList $statements, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$statements.getType().isSubtypeOf(tf.listType(_Statement))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Statement) + " but got " + $statements.getType() + " for $statements:" + $statements);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_compoundStatement_2 , $attributes, $statements).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_if(IList $attributes, IConstructor $condition, IConstructor $thenClause, IConstructor $elseClause, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$thenClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $thenClause.getType() + " for $thenClause:" + $thenClause);
    }
      
    if (!$elseClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $elseClause.getType() + " for $elseClause:" + $elseClause);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_if_4 , $attributes, $condition, $thenClause, $elseClause).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_case(IList $attributes, IConstructor $expression, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_case_2 , $attributes, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_catch(IList $attributes, IConstructor $declaration, IConstructor $body, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_catch_3 , $attributes, $declaration, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_return(IList $attributes, IConstructor $expression, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_return_2 , $attributes, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
    
  
  public IConstructor Modifier_override(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_override_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_public(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_public_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_typename(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_typename_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_mutable(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_mutable_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_threadLocal(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_threadLocal_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_extern(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_extern_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_friend(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_friend_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_unsigned(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_unsigned_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_final(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_final_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_captDefByReference(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_captDefByReference_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_complex(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_complex_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_auto(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_auto_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_captDefByCopy(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_captDefByCopy_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_protected(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_protected_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_static(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_static_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_virtual(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_virtual_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_typedef(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_typedef_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_const(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_const_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_register(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_register_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_private(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_private_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_signed(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_signed_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_restrict(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_restrict_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_long(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_long_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_volatile(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_volatile_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_short(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_short_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_inline(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_inline_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_imaginary(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_imaginary_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_constexpr(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_constexpr_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_longlong(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_longlong_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_explicit(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_explicit_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_captDefUnspecified(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_captDefUnspecified_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_unspecifiedInheritance(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_unspecifiedInheritance_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_pureVirtual(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_pureVirtual_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
    
  
  public IConstructor TypeSymbol_float() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_float_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_double() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_double_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_unspecified() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_unspecified_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_class(ISourceLocation $decl) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_class_1 , $decl).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_unknownMemberClass(IConstructor $owner, String $name) {
      
    if (!$owner.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $owner.getType() + " for $owner:" + $owner);
    }
      
    if (!vf.string($name).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($name).getType() + " for vf.string($name):" + vf.string($name));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_unknownMemberClass_2 , $owner, vf.string($name)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_functionType(IConstructor $returnType, IList $parameterTypes) {
      
    if (!$returnType.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $returnType.getType() + " for $returnType:" + $returnType);
    }
      
    if (!$parameterTypes.getType().isSubtypeOf(tf.listType(_TypeSymbol))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeSymbol) + " but got " + $parameterTypes.getType() + " for $parameterTypes:" + $parameterTypes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_functionType_2 , $returnType, $parameterTypes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_problemType() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_problemType_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_functionTypeVarArgs(IConstructor $returnType, IList $parameterTypes) {
      
    if (!$returnType.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $returnType.getType() + " for $returnType:" + $returnType);
    }
      
    if (!$parameterTypes.getType().isSubtypeOf(tf.listType(_TypeSymbol))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeSymbol) + " but got " + $parameterTypes.getType() + " for $parameterTypes:" + $parameterTypes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_functionTypeVarArgs_2 , $returnType, $parameterTypes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_noType() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_noType_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_float128() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_float128_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_char16() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_char16_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_union(ISourceLocation $decl) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_union_1 , $decl).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_templateTypeParameter(String $ownerName, String $name) {
      
    if (!vf.string($ownerName).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($ownerName).getType() + " for vf.string($ownerName):" + vf.string($ownerName));
    }
      
    if (!vf.string($name).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($name).getType() + " for vf.string($name):" + vf.string($name));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_templateTypeParameter_2 , vf.string($ownerName), vf.string($name)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_typeOfDependentExpression(ISourceLocation $src) {
      
    if (!$src.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $src.getType() + " for $src:" + $src);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_typeOfDependentExpression_1 , $src).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_array(IConstructor $baseType) {
      
    if (!$baseType.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_array_1 , $baseType).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_qualifierType(IList $modifiers, IConstructor $type) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_TypeModifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeModifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$type.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_qualifierType_2 , $modifiers, $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_decimal32() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_decimal32_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_enumerationSpecialization(ISourceLocation $specializedBinding, IList $templateArguments) {
      
    if (!$specializedBinding.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $specializedBinding.getType() + " for $specializedBinding:" + $specializedBinding);
    }
      
    if (!$templateArguments.getType().isSubtypeOf(tf.listType(_TypeSymbol))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeSymbol) + " but got " + $templateArguments.getType() + " for $templateArguments:" + $templateArguments);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_enumerationSpecialization_2 , $specializedBinding, $templateArguments).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_char32() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_char32_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_enumeration(ISourceLocation $decl) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_enumeration_1 , $decl).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_typeContainer(IConstructor $type) {
      
    if (!$type.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_typeContainer_1 , $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_void() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_void_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_char() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_char_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_referenceType(IConstructor $type) {
      
    if (!$type.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_referenceType_1 , $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_boolean() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_boolean_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_int128() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_int128_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_wchar() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_wchar_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_pointerType(IList $modifiers, IConstructor $type) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_TypeModifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeModifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$type.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_pointerType_2 , $modifiers, $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_any() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_any_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_classSpecialization(ISourceLocation $decl, IList $templateArguments) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateArguments.getType().isSubtypeOf(tf.listType(_TypeSymbol))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeSymbol) + " but got " + $templateArguments.getType() + " for $templateArguments:" + $templateArguments);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_classSpecialization_2 , $decl, $templateArguments).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_parameterPackType(IConstructor $type) {
      
    if (!$type.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_parameterPackType_1 , $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_decimal64() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_decimal64_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_int() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_int_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_struct(IList $fields) {
      
    if (!$fields.getType().isSubtypeOf(tf.listType(_TypeSymbol))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeSymbol) + " but got " + $fields.getType() + " for $fields:" + $fields);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_struct_1 , $fields).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_deferredClassInstance(String $name) {
      
    if (!vf.string($name).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($name).getType() + " for vf.string($name):" + vf.string($name));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_deferredClassInstance_1 , vf.string($name)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_array(IConstructor $baseType, IValue $size) {
      
    if (!$baseType.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
      
    if (!$size.getType().isSubtypeOf(tf.integerType())) {
      throw new IllegalArgumentException("Expected " + tf.integerType() + " but got " + $size.getType() + " for $size:" + $size);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_array_2 , $baseType, $size).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_nullPtr() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_nullPtr_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_decimal128() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_decimal128_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_basicType(IList $modifiers, IConstructor $baseType) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_TypeModifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeModifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$baseType.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_basicType_2 , $modifiers, $baseType).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_problemBinding() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeSymbol_problemBinding_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
    
  
  public IConstructor Attribute_attribute(String $name, ISourceLocation $loc) {
      
    if (!vf.string($name).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($name).getType() + " for vf.string($name):" + vf.string($name));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Attribute_attribute_1 , vf.string($name)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Attribute_attributeSpecifier(IList $attributes, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Attribute_attributeSpecifier_1 , $attributes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Attribute_attribute(String $name, String $argumentClause, ISourceLocation $loc) {
      
    if (!vf.string($name).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($name).getType() + " for vf.string($name):" + vf.string($name));
    }
      
    if (!vf.string($argumentClause).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($argumentClause).getType() + " for vf.string($argumentClause):" + vf.string($argumentClause));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Attribute_attribute_2 , vf.string($name), vf.string($argumentClause)).asWithKeywordParameters().setParameters(kwParams);
  }
    
  
  public IConstructor TypeModifier_unsigned() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeModifier_unsigned_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_complex() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeModifier_complex_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_imaginary() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeModifier_imaginary_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_longlong() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeModifier_longlong_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_const() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeModifier_const_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_static() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeModifier_static_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_short() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeModifier_short_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_volatile() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeModifier_volatile_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_long() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeModifier_long_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_restrict() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeModifier_restrict_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_signed() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    return vf.constructor(_TypeModifier_signed_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
   
  
}